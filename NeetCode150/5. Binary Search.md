# 875. Koko Eating Bananas
*  **ä¸€åˆ·: 40 mins(âŒ)**
* [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)

## çŸ¥è¯†ç‚¹
### 1. Binary Searchçš„å·¦é—­å³é—­
* å·¦é—­å³é—­å†™æ³•
```java
while(left <= right){
    right = mid - 1;
    left = mid + 1;
}
```

* å·¦é—­å³å¼€å†™æ³•
```java
while(left < right){
    right = mid;
    left = mid + 1;
}
```
## æ€è·¯1: é€Ÿåº¦çš„å˜åŒ–é€šè¿‡speed = (left + right)/2ç›´æ¥æ›´æ–°
* é€šè¿‡binary searchæ¥éå†é€Ÿåº¦speedï¼Œç„¶ååœ¨whileä¸­ä¸€ä¸ªforå¾ªç¯æ¥æ¯æ¬¡éå†pileä»è€Œå¾—å‡ºtotalTimeã€‚å¦‚æœ`totalTime<h` speed = rightï¼Œvice versa
```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        Arrays.sort(piles);
        int left = 1, right = piles[piles.length - 1];
        int k = right;
        int res = Integer.MAX_VALUE;
        while(left <= right){
            int speed = (left + right)/2;
            int totalTime = 0;
            for(int pile: piles){
                totalTime += Math.ceil((double) pile/speed);
            }
            if(totalTime > h){
                left = speed + 1;
            }else {
                res = Math.min(res, speed);
                right = speed - 1;
            }
        }
        return res;
    }
}
```
***
# 4. Median of Two Sorted Arrays
*  **ä¸€åˆ·: 40 mins(âŒ)**
* [4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)
## æ€è·¯1: å¤§å°æ•°ç»„ï¼Œä»¥å°ä¸ºåŸºå‡†ï¼Œbinary search
* é¦–å…ˆé€šè¿‡æ¯”è¾ƒå¤§å°æ‰¾åˆ°å°çš„é‚£ä¸ªArrayï¼Œä»¥ä»–ä¸ºåŸºå‡†Aã€‚å¤§çš„é‚£ä¸ªé€šè¿‡half - Aæ¥è¿›è¡Œç§»åŠ¨
* åˆ†åˆ«æ‰¾åˆ°binaryä½ç½®ï¼Œæ¡†å†…å’Œæ¡†å¤–çš„ï¼ŒAleft,Aright,Bleft,Bright
* é€šè¿‡æ¯”è¾ƒ(Aleft,Bright)å’Œ(Aright,Bleft)æ¥ç¡®å®šæ˜¯å¦æ˜¯æ­£ç¡®çš„mid
  * å¦‚æœAleftæ¯”Brightå¤§äº†ï¼Œè¯´æ˜Açš„æ¡†ä½ç½®å¤šäº†ï¼Œåº”è¯¥å‡å°ï¼Œr = midA - 1;
  * å¦‚æœBleftæ¯”Arightå¤§äº†ï¼Œè¯´æ˜Açš„ä½ç½®è¿˜ä¸å¤Ÿï¼Œåº”è¯¥å†å¤šå–ç‚¹Aï¼Œl = midA + 1;
### æŠ€å·§: int Aleft = midA > 0 ? A[midA - 1] : Integer.MIN_VALUE;
* Edge Case:å½“Aæ•°ç»„ä¸º0ï¼Œæˆ–è€…Açš„æ•°ç»„å·²ç»å–æ»¡äº†
  * A == 0æ—¶ï¼ŒmidA == 0, å°±å°†Aæ•°ç»„å·¦è¾¹ğŸ‘ˆåŠ ä¸€ä¸ªè´Ÿæ— ç©·
  * A == A.lengthæ—¶ï¼Œè¯´æ˜Aå·²ç»åˆ°åº•äº†ï¼ŒAæ•°ç»„å³è¾¹ğŸ‘‰åŠ ä¸€ä¸ªæ­£æ— ç©·
### æ˜“é”™: lå’Œr ä»¥åŠ Aleftï¼ŒAright ä»¥åŠmidAçš„åæ ‡ä½ç½®å®¹æ˜“ææ··
* l = 0ï¼Œr = A.lengthï¼Œä»–ä»¬çš„midA = (l + r)/2. è¿™ä¸ªmidA ä¸æ˜¯binaryçš„æ¡†çš„è¾¹ç•Œï¼Œè€Œæ˜¯ä¸ºäº†æ–¹ä¾¿è®¡ç®— midB = len - midA. ä»–ä»¬éƒ½æ˜¯æ¡†æ¡†çš„å³è¾¹(å› ä¸º0-index)
* å½“åˆ°è¾¾äº†åº•è¾¹ï¼Œè¯´æ˜Açš„æ‰€æœ‰å€¼è‚¯å®šæ˜¯å°äºç­‰äºBmidä¹‹åçš„ï¼Œé‚£ä¹ˆæ¡ä»¶Aleft <= Bright && Aright >= Bleft ä¸€å®šä¼šæ»¡è¶³ï¼Œç›´æ¥è¿”å›ç­”æ¡ˆ

## Code
```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int[] A;
        int[] B;
        if (nums1.length <= nums2.length) {
            A = nums1;
            B = nums2;
        } else {
            A = nums2;
            B = nums1;
        }
        int total = A.length + B.length;
        int half = total / 2;
        int l = 0;
        int r = A.length;
        while (l <= r) {
            int midA = (l + r) / 2;
            int midB = half - midA;

            int Aleft = midA > 0 ? A[midA - 1] : Integer.MIN_VALUE;
            int Aright = midA < A.length ? A[midA] : Integer.MAX_VALUE;
            int Bleft = midB > 0 ? B[midB - 1] : Integer.MIN_VALUE;
            int Bright = midB < B.length ? B[midB] : Integer.MAX_VALUE;

            if (Aleft <= Bright && Aright >= Bleft) {
                if (total % 2 == 1) {
                    return (double) Math.min(Aright, Bright);
                } else {
                    return (Math.max(Aleft, Bleft) + Math.min(Aright, Bright)) / 2.0;
                }
            }
            if (Aleft > Bright) {
                r = midA - 1;
            } else {
                l = midA + 1;
            }
        }
        return -1;
    }
}
```