# 543. Diameter of Binary Tree
*  **一刷: 10 mins(❌)**
* [543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/)
## 思路1: 递归
* 通过depth计算两侧的最大深度，但结果是求最大直径，所以通过一个global variable 记录max

### Code
```java
class Solution {
    int max = 0;
    
    public int diameterOfBinaryTree(TreeNode root) {
        depth(root);  
        return max;  
    }
    
    private int depth(TreeNode root){
        if(root == null){
            return 0;
        }
        int left = depth(root.left);
        int right = depth(root.right);
        max = Math.max(max, left + right);  
        return Math.max(left, right) + 1;   
    }
}

```
# 572. Subtree of Another Tree
*  **一刷: 10 mins(❌)**
* [572. Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree/)

## 思路1: 两个方法，一个isSubtree只用来找起点；一个isSame判断是否相同
* isSubtree只用来traverse tree，找到相同的起点
* isSame用来判断起点下的树是否相同
## Code
```java
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        if (subRoot == null) {
            return true;
        }
        if (root == null) {
            return false;
        }
        if (isSame(root, subRoot)) {
            return true;
        }
        return isSubtree(root.left, subRoot) || isSubtree (root.right, subRoot);
    }

    private boolean isSame(TreeNode root, TreeNode subRoot) {
        if (root == null && subRoot == null)
            return true;
        if (root != null && subRoot != null && root.val == subRoot.val) {
            return isSame(root.left, subRoot.left) && isSame(root.right, subRoot.right);
        }
        return false;
    }
}
```
# 98. Validate Binary Search Tree
*  **一刷: 15 mins(❌)**
* [98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)

## 思路1: 通过leftMax记录左边
* inorder遍历，通过in来操作
* 通过一个全局变量来找到leftMax，找到left的最大，然后通过**root进行更新！** ==> leftMax = root;
* inorder 特别适配：sorting，binary search，因为天然有序
* 注意inorder在中间操作，可以boolean left 来获取left的值

## Code
```java
class Solution {
    TreeNode leftMax = null;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        //left
        boolean left = isValidBST(root.left);
        //in
        if(!left) return false;
        if(leftMax!=null && leftMax.val >= root.val){
            return false;
        }
        leftMax = root;
        //right
        return isValidBST(root.right);
    }
}
```
***
# 230. Kth Smallest Element in a BST
*  **一刷: 15 mins(✅)**
* [230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)
## 思路1: DFS- Inorder Traversal
### Recursion的空间复杂度是O(N)
* 因为在每次调用Recursion的时候会记录当前的值
### 当只想使用recursion进行遍历，不返回最后的结果时
* 可以定义一个global variable

## Code
```java
class Solution {
    int index = 0;
    int res = 0;
    public int kthSmallest(TreeNode root, int k) {
        // in-order traverse find the kth
        if (root == null) {
            return 0;
        }
        kthSmallest(root.left, k);
        index++;
        if (k == index) {
            res = root.val;
        }
        kthSmallest(root.right, k);
        return res;
    }
}
```
