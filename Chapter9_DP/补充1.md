# 120. Triangle
* **一刷:39:49(✅)**
* [120. Triangle](https://leetcode.com/problems/triangle/?envType=study-plan-v2&envId=top-interview-150)

## 问题
### Q1. 如何使用Dp来实现？这个需要全部情况都依次尝试才可以呀。比如有个值很小，如果回退得很深，那么我的dp数组表示的是什么？
* 通过二维数组记录所有内容

## My Code
```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        //dp: the mini of dp[i - 1][j] & dp[i - 1][j - 1];
        int n = triangle.size();
        int [][] dp = new int [n][n];
        int level = 0;
        for(int i = 0; i <= level; i ++){
            if(i >= n) break;
            for (int j = 0; j <= level; j ++){
                int cur = triangle.get(i).get(j);
                if(i - 1 < 0) {
                    dp[i][j] = cur;
                    level ++;
                    break;
                }
                if(j - 1 < 0){
                    dp[i][j] = cur + dp[i - 1][j]; 
                    continue;
                }
                if( j >= triangle.get(i).size() - 1){
                    dp[i][j] = cur + dp[i - 1][j - 1];
                    level ++;
                    break;
                }
                dp[i][j] = cur + Math.min(dp[i - 1][j - 1], dp[i - 1][j]);
                level ++;
            }

        }
        int res = Integer.MAX_VALUE;
        for(int i = 0 ; i < n ; i ++){
            res = Math.min(res, dp[n - 1][i]);
        }
        return res;
    }
}
```
***
# 64. Minimum Path Sum
* **一刷:10:23(✅)**
* [120. Triangle](https://leetcode.com/problems/minimum-path-sum/?envType=study-plan-v2&envId=top-interview-150)

## My Code
```java
class Solution {
    public int minPathSum(int[][] grid) {
        int row = grid.length;
        int col = grid[0].length;
        int [][] dp = new int [row][col];

        dp[0][0] = grid[0][0];
        //initiate top-row
        for(int i = 1; i < col; i ++){
            dp[0][i] = grid[0][i] + dp[0][i - 1];
        }
        //initiate left-col
        for(int i = 1; i < row; i ++){
            dp[i][0] = grid[i][0] + dp[i - 1][0];
        }

        for(int i = 1; i < row; i ++){
            for (int j = 1; j < col; j ++){
                dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[row - 1][col - 1];
    }
}
```
